import fs, { readFileSync, existsSync, unlinkSync, writeFileSync, readdirSync, statSync } from 'fs';
import path, { relative, sep, basename } from 'path';
import CleanCss from 'clean-css';
import crypto from 'crypto';
import require$$0 from 'worker_threads';

const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function' &&
	typeof stream._transformState === 'object';

var isStream_1 = isStream;

const {Worker} = (() => {
	try {
		return require$$0;
	} catch (_) {
		return {};
	}
})();

let worker; // Lazy
let taskIdCounter = 0;
const tasks = new Map();

const recreateWorkerError = sourceError => {
	const error = new Error(sourceError.message);

	for (const [key, value] of Object.entries(sourceError)) {
		if (key !== 'message') {
			error[key] = value;
		}
	}

	return error;
};

const createWorker = () => {
	worker = new Worker(path.join(__dirname, 'thread.js'));

	worker.on('message', message => {
		const task = tasks.get(message.id);
		tasks.delete(message.id);

		if (tasks.size === 0) {
			worker.unref();
		}

		if (message.error === undefined) {
			task.resolve(message.value);
		} else {
			task.reject(recreateWorkerError(message.error));
		}
	});

	worker.on('error', error => {
		// Any error here is effectively an equivalent of segfault, and have no scope, so we just throw it on callback level
		throw error;
	});
};

const taskWorker = (method, args, transferList) => new Promise((resolve, reject) => {
	const id = taskIdCounter++;
	tasks.set(id, {resolve, reject});

	if (worker === undefined) {
		createWorker();
	}

	worker.ref();
	worker.postMessage({id, method, args}, transferList);
});

const hasha = (input, options = {}) => {
	let outputEncoding = options.encoding || 'hex';

	if (outputEncoding === 'buffer') {
		outputEncoding = undefined;
	}

	const hash = crypto.createHash(options.algorithm || 'sha512');

	const update = buffer => {
		const inputEncoding = typeof buffer === 'string' ? 'utf8' : undefined;
		hash.update(buffer, inputEncoding);
	};

	if (Array.isArray(input)) {
		input.forEach(update);
	} else {
		update(input);
	}

	return hash.digest(outputEncoding);
};

hasha.stream = (options = {}) => {
	let outputEncoding = options.encoding || 'hex';

	if (outputEncoding === 'buffer') {
		outputEncoding = undefined;
	}

	const stream = crypto.createHash(options.algorithm || 'sha512');
	stream.setEncoding(outputEncoding);
	return stream;
};

hasha.fromStream = async (stream, options = {}) => {
	if (!isStream_1(stream)) {
		throw new TypeError('Expected a stream');
	}

	return new Promise((resolve, reject) => {
		// TODO: Use `stream.pipeline` and `stream.finished` when targeting Node.js 10
		stream
			.on('error', reject)
			.pipe(hasha.stream(options))
			.on('error', reject)
			.on('finish', function () {
				resolve(this.read());
			});
	});
};

if (Worker === undefined) {
	hasha.fromFile = async (filePath, options) => hasha.fromStream(fs.createReadStream(filePath), options);
	hasha.async = async (input, options) => hasha(input, options);
} else {
	hasha.fromFile = async (filePath, {algorithm = 'sha512', encoding = 'hex'} = {}) => {
		const hash = await taskWorker('hashFile', [algorithm, filePath]);

		if (encoding === 'buffer') {
			return Buffer.from(hash);
		}

		return Buffer.from(hash).toString(encoding);
	};

	hasha.async = async (input, {algorithm = 'sha512', encoding = 'hex'} = {}) => {
		if (encoding === 'buffer') {
			encoding = undefined;
		}

		const hash = await taskWorker('hash', [algorithm, input]);

		if (encoding === undefined) {
			return Buffer.from(hash);
		}

		return Buffer.from(hash).toString(encoding);
	};
}

hasha.fromFileSync = (filePath, options) => hasha(fs.readFileSync(filePath), options);

var hasha_1 = hasha;

const cheerio = require('cheerio');

function traverse(dir, list, exclude = []) {
	const dirList = readdirSync(dir);
	dirList.forEach(node => {
		const file = `${dir}/${node}`;
		if (!exclude.includes(node)) {
			if (statSync(file).isDirectory()) {
				traverse(file, list, exclude);
			} else {
				if (/\.js$/.test(file)) {
					list.push({ type: 'js', file });
				} else if (/\.css$/.test(file)) {
					list.push({ type: 'css', file });
				}
			}
		}
	});
}

function isURL(url) {
	return (new RegExp('^(?:[a-z]+:)?//', 'i')).test(url);
}

function isRollupV2(options) {
	return options.assetFileNames && options.entryFileNames;
}

var index = (opt = {}) => {
	const { 
		scriptType = 'text/javascript',
		onlinePath,
		externals,
		minifyCss,
		template,
		filename,
		absolute,
		exclude,
		inject,
		inline,
		ignore,
		clean,
		dest,
	} = opt;

	return {
		name: 'html',
		writeBundle: function writeBundle(options, data) {
			const { config, bundle } = isRollupV2(options) ? { config: data, bundle: data.code } :
				{ config: options, bundle: options.code };

			const isHTML = /^.*<html>.*<\/html>$/.test(template);
			const $ = cheerio.load(isHTML?template:readFileSync(template).toString());
			const head = $('head');
			const body = $('body');
			let entryConfig = {};
			Object.values(config).forEach((c) => {
				if (c.isEntry) entryConfig = c;
			});
			const { fileName,	sourcemap } = entryConfig;
			const fileList = [];
			// relative('./', file) will not be equal to file when file is a absolute path
			const destPath = relative('./', fileName);
			const destDir = dest || destPath.slice(0, destPath.indexOf(sep));
			const destFile = `${destDir}/${filename || basename(template)}`;
			const absolutePathPrefix = absolute ? '/' : '';

			traverse(destDir, fileList, exclude);

			if (Array.isArray(externals)) {
				let firstBundle = 0;
				externals.forEach(function (node) {
					if (node.pos === 'before') {
						fileList.splice(firstBundle++, 0, node);
					} else {
						fileList.splice(fileList.length, 0, node);
					}
				});
			}

			const processedFiles = [];

			fileList.forEach(node => {
				let { type, file, content, inject: fileInject } = node;

				const external = content || !existsSync(file);

				if (ignore && file.match(ignore)) {
					return;
				}

				let hash = '';
				let code = '';
				const isHash = /\[hash\]/.test(file);

				if ((inline || isHash) && !external) {
					if (file === destPath) {
						// bundle will remove the last line of the source code(//# sourceMappingURL=xxx), so it's needed to add this
						code = `${bundle}//# sourceMappingURL=${basename(file)}.map`;
					} else {
						code = readFileSync(file).toString();
					}
				}

				if (isHash && !external) {
					if (sourcemap) {
						let srcmapFile = file + ".map";
						let srcmapCode = readFileSync(srcmapFile).toString();
						let srcmapHash = hasha_1(srcmapCode, { algorithm: 'md5' });

						// remove the source map file without hash
						unlinkSync(srcmapFile);
						srcmapFile = srcmapFile.replace('[hash]', srcmapHash);
						writeFileSync(srcmapFile, srcmapCode);

						code = code.replace(`//# sourceMappingURL=${basename(file)}.map`, `//# sourceMappingURL=${basename(srcmapFile)}`);
					}
					hash = hasha_1(code, { algorithm: 'md5' });
					// remove the file without hash
					unlinkSync(file);
					file = file.replace('[hash]', hash);
					writeFileSync(file, code);
				}

				
				let src = (isURL(file) || external) ? file : absolutePathPrefix + relative(destDir, file).replace(/\\/g, '/');
				if (onlinePath) {
					const filename = file.split('/').slice(-1)[0];
					const slash = onlinePath.slice(-1) === '/' ? '' : '/';
					src = onlinePath + slash + filename;
				}
				if (node.timestamp) {
                    src += '?t=' + (new Date()).getTime();
				}

				if (type === 'js') {

					const content = inline && !external && code ? 
						`<script type="${scriptType}">\n${code}\n</script>\n` : 
						`<script type="${scriptType}" src="${src}"></script>\n`;

					(fileInject || inject) === 'head' ? head.append(content) : body.append(content);
				} else if (type === 'css') {

					const content = inline && !external && code ? 
						`<style>\n${minifyCss ? new CleanCss().minify(code).styles : code}\n</style>\n` : 
						`<link rel="stylesheet" href="${src}">\n`;

					fileInject === 'body' ? body.append(content) : head.append(content);
				} else if (content) {
					(fileInject || inject) === 'head' ? head.append(content) : body.append(content);
				}

				processedFiles.push(node);
			});
			if (clean) processedFiles.forEach(f => existsSync(f.file) && unlinkSync(f.file));
			writeFileSync(destFile, $.html());
		}
	};
};

export default index;
